<!DOCTYPE html>
<html>
<head>
    <title>Auto File Server</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; }
        .endpoint { background: #f5f5f5; padding: 10px; margin: 10px 0; border-radius: 5px; }
        .file-item { padding: 5px; margin: 2px 0; }
        .folder { color: #007cba; font-weight: bold; }
        pre { background: #f8f8f8; padding: 10px; border-radius: 5px; overflow-x: auto; }
    </style>
</head>
<body>
    <h1>üöÄ Auto File Server</h1>
    <div id="status">Initializing server...</div>
    <div id="content"></div>

    <script>
        class FileServer {
            constructor() {
                this.fileCache = new Map();
                this.directoryHandle = null;
                this.init();
            }

            async init() {
                try {
                    // Auto-start on load
                    await this.startServer();
                } catch (error) {
                    document.getElementById('status').innerHTML = 
                        `‚ùå Server failed to start: ${error.message}`;
                }
            }

            async startServer() {
                const status = document.getElementById('status');
                status.innerHTML = 'üîÑ Starting server...';

                // Auto-request file access
                await this.requestFileAccess();
                
                // Start virtual server
                this.setupVirtualServer();
                
                status.innerHTML = '‚úÖ Server started successfully!';
                
                // Show root endpoint
                this.showRoot();
            }

            async requestFileAccess() {
                if (!('showDirectoryPicker' in window)) {
                    throw new Error('File System Access API not supported. Use Chrome 86+.');
                }

                // Auto-request directory access
                this.directoryHandle = await window.showDirectoryPicker();
                await this.cacheFiles();
            }

            async cacheFiles() {
                this.fileCache.clear();
                
                for await (const entry of this.directoryHandle.values()) {
                    if (entry.kind === 'file') {
                        try {
                            const file = await entry.getFile();
                            this.fileCache.set(file.name, {
                                name: file.name,
                                size: file.size,
                                type: file.type,
                                lastModified: file.lastModified,
                                content: await file.text()
                            });
                        } catch (error) {
                            console.warn('Could not read file:', entry.name, error);
                        }
                    }
                }
            }

            setupVirtualServer() {
                // Override fetch to handle our virtual endpoints
                const originalFetch = window.fetch;
                window.fetch = async (input, init) => {
                    const url = typeof input === 'string' ? input : input.url;
                    
                    if (url.startsWith('/')) {
                        return this.handleRequest(url);
                    }
                    
                    return originalFetch(input, init);
                };

                // Handle browser navigation
                window.handleServerRoute = (route) => {
                    this.handleRoute(route);
                };

                // Set up route handling
                window.addEventListener('hashchange', () => {
                    this.handleRoute(window.location.hash.substring(1));
                });

                // Initial route
                this.handleRoute(window.location.hash.substring(1) || '/');
            }

            handleRoute(route) {
                const content = document.getElementById('content');
                
                switch(route) {
                    case '/':
                        this.showRoot();
                        break;
                    case '/folders':
                        this.showFolders();
                        break;
                    case '/files':
                        this.showFiles();
                        break;
                    default:
                        if (route.startsWith('/file/')) {
                            this.downloadFile(route.replace('/file/', ''));
                        } else {
                            content.innerHTML = `<div class="error">‚ùå Endpoint not found: ${route}</div>`;
                        }
                }
            }

            async handleRequest(url) {
                let responseData;

                switch(url) {
                    case '/':
                        responseData = this.getRootResponse();
                        break;
                    case '/folders':
                        responseData = this.getFoldersResponse();
                        break;
                    case '/files':
                        responseData = this.getFilesResponse();
                        break;
                    default:
                        if (url.startsWith('/file/')) {
                            return this.getFileResponse(url.replace('/file/', ''));
                        } else {
                            responseData = { error: 'Endpoint not found', available: ['/', '/folders', '/files', '/file/{filename}'] };
                        }
                }

                return new Response(JSON.stringify(responseData, null, 2), {
                    headers: { 'Content-Type': 'application/json' }
                });
            }

            getRootResponse() {
                return {
                    server: "Auto File Server",
                    endpoints: [
                        { method: "GET", path: "/", description: "List all available endpoints" },
                        { method: "GET", path: "/folders", description: "List all folders in selected directory" },
                        { method: "GET", path: "/files", description: "List all files in selected directory" },
                        { method: "GET", path: "/file/{filename}", description: "Download specific file" }
                    ],
                    stats: {
                        totalFiles: this.fileCache.size,
                        directory: this.directoryHandle?.name || 'Unknown'
                    }
                };
            }

            getFoldersResponse() {
                const folders = new Set();
                
                // In a real implementation, you would traverse directories
                // For now, we'll simulate folder structure based on file extensions
                this.fileCache.forEach(file => {
                    const ext = file.name.split('.').pop();
                    folders.add(ext ? `${ext.toUpperCase()} Files` : 'No Extension');
                });

                return {
                    folders: Array.from(folders),
                    count: folders.size,
                    directory: this.directoryHandle?.name || 'Unknown'
                };
            }

            getFilesResponse() {
                const files = Array.from(this.fileCache.values()).map(file => ({
                    name: file.name,
                    size: file.size,
                    sizeFormatted: this.formatFileSize(file.size),
                    type: file.type,
                    lastModified: new Date(file.lastModified).toISOString(),
                    downloadUrl: `/file/${encodeURIComponent(file.name)}`
                }));

                return {
                    files: files,
                    count: files.length,
                    totalSize: this.formatFileSize(Array.from(this.fileCache.values()).reduce((sum, file) => sum + file.size, 0))
                };
            }

            getFileResponse(filename) {
                const decodedFilename = decodeURIComponent(filename);
                
                if (!this.fileCache.has(decodedFilename)) {
                    return new Response(JSON.stringify({
                        error: 'File not found',
                        availableFiles: Array.from(this.fileCache.keys())
                    }), {
                        status: 404,
                        headers: { 'Content-Type': 'application/json' }
                    });
                }

                const file = this.fileCache.get(decodedFilename);
                return new Response(file.content, {
                    headers: {
                        'Content-Type': file.type || 'application/octet-stream',
                        'Content-Disposition': `attachment; filename="${decodedFilename}"`
                    }
                });
            }

            showRoot() {
                const content = document.getElementById('content');
                const response = this.getRootResponse();
                
                let html = `<h2>üì° Server Endpoints</h2>`;
                html += `<div class="endpoint">
                    <strong>Server Status:</strong> Running<br>
                    <strong>Directory:</strong> ${response.stats.directory}<br>
                    <strong>Files Cached:</strong> ${response.stats.totalFiles}
                </div>`;
                
                html += `<h3>Available Endpoints:</h3>`;
                response.endpoints.forEach(endpoint => {
                    html += `<div class="endpoint">
                        <strong>${endpoint.method} ${endpoint.path}</strong><br>
                        ${endpoint.description}
                    </div>`;
                });

                html += `<h3>Quick Access:</h3>`;
                html += `<button onclick="handleServerRoute('/folders')">üìÅ View Folders</button> `;
                html += `<button onclick="handleServerRoute('/files')">üìÑ View Files</button>`;

                content.innerHTML = html;
            }

            showFolders() {
                const content = document.getElementById('content');
                const response = this.getFoldersResponse();
                
                let html = `<h2>üìÅ Folders in ${response.directory}</h2>`;
                html += `<div>Total: ${response.count} folder types</div>`;
                
                response.folders.forEach(folder => {
                    html += `<div class="file-item folder">üìÅ ${folder}</div>`;
                });

                html += `<br><button onclick="handleServerRoute('/')">‚Üê Back to Home</button>`;
                content.innerHTML = html;
            }

            showFiles() {
                const content = document.getElementById('content');
                const response = this.getFilesResponse();
                
                let html = `<h2>üìÑ Files in Directory</h2>`;
                html += `<div>Total: ${response.count} files (${response.totalSize})</div>`;
                
                response.files.forEach(file => {
                    html += `<div class="file-item">
                        <strong>üìÑ ${file.name}</strong><br>
                        <small>Size: ${file.sizeFormatted} | Type: ${file.type || 'Unknown'} </small>
                        <button onclick="downloadFile('${file.name}')" style="margin-left: 10px;">Download</button>
                    </div>`;
                });

                html += `<br><button onclick="handleServerRoute('/')">‚Üê Back to Home</button>`;
                content.innerHTML = html;
            }

            downloadFile(filename) {
                const file = this.fileCache.get(filename);
                if (file) {
                    const blob = new Blob([file.content], { type: file.type });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = filename;
                    a.click();
                    URL.revokeObjectURL(url);
                }
            }

            formatFileSize(bytes) {
                if (bytes === 0) return '0 B';
                const k = 1024;
                const sizes = ['B', 'KB', 'MB', 'GB'];
                const i = Math.floor(Math.log(bytes) / Math.log(k));
                return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
            }
        }

        // Global function for navigation
        window.handleServerRoute = (route) => {
            window.location.hash = route;
        };

        window.downloadFile = (filename) => {
            if (window.fileServer) {
                window.fileServer.downloadFile(filename);
            }
        };

        // Auto-start the server when page loads
        window.addEventListener('load', () => {
            window.fileServer = new FileServer();
        });

        // Handle direct URL access
        window.addEventListener('hashchange', () => {
            const route = window.location.hash.substring(1) || '/';
            if (window.fileServer) {
                window.fileServer.handleRoute(route);
            }
        });
    </script>
</body>
</html>